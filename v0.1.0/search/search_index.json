{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"obspec","text":"<p>A Python protocol for interfacing with object storage.</p> <p>Read the release post.</p> <p>It's designed to abstract away the complexities of different object storage providers while acknowledging that object storage is not a filesystem. The Python protocols present more similarities to HTTP requests than Python file objects.</p>"},{"location":"#implementations","title":"Implementations","text":"<p>The primary implementation that implements obspec is obstore, and the obspec protocol was designed around the obstore API.</p>"},{"location":"#utilities","title":"Utilities","text":"<p>There are planned to be utilities that build on top of obspec. Potentially:</p> <ul> <li>globbing: an implementation of <code>glob()</code> similar to <code>fsspec.glob</code> that uses <code>obspec</code> primitives.</li> <li>Caching: wrappers around <code>Get</code>/<code>GetRange</code>/<code>GetRanges</code> that store a cache of bytes.</li> </ul> <p>By having these utilities operate on generic obspec protocols, it means that they can instantly be used with any future obspec backend.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#010-2025-06-25","title":"[0.1.0] - 2025-06-25","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"api/attributes/","title":"Attributes","text":""},{"location":"api/attributes/#obspec.Attribute","title":"obspec.Attribute  <code>module-attribute</code>","text":"<pre><code>Attribute: TypeAlias = Union[\n    Literal[\n        \"Content-Disposition\",\n        \"Content-Encoding\",\n        \"Content-Language\",\n        \"Content-Type\",\n        \"Cache-Control\",\n    ],\n    str,\n]\n</code></pre> <p>Additional object attribute types.</p> <ul> <li> <p><code>\"Content-Disposition\"</code>: Specifies how the object should be handled by a browser.</p> <p>See Content-Disposition.</p> </li> <li> <p><code>\"Content-Encoding\"</code>: Specifies the encodings applied to the object.</p> <p>See Content-Encoding.</p> </li> <li> <p><code>\"Content-Language\"</code>: Specifies the language of the object.</p> <p>See Content-Language.</p> </li> <li> <p><code>\"Content-Type\"</code>: Specifies the MIME type of the object.</p> <p>This takes precedence over any client configuration.</p> <p>See Content-Type.</p> </li> <li> <p><code>\"Cache-Control\"</code>: Overrides cache control policy of the object.</p> <p>See Cache-Control.</p> </li> </ul> <p>Any other string key specifies a user-defined metadata field for the object.</p>"},{"location":"api/attributes/#obspec.Attributes","title":"obspec.Attributes  <code>module-attribute</code>","text":"<pre><code>Attributes: TypeAlias = dict[Attribute, str]\n</code></pre> <p>Additional attributes of an object</p> <p>Attributes can be specified in <code>Put</code>/<code>PutAsync</code> and retrieved from <code>Get</code>/<code>GetAsync</code>.</p> <p>Unlike ObjectMeta, Attributes are not returned by listing APIs</p>"},{"location":"api/copy/","title":"Copy","text":""},{"location":"api/copy/#obspec.Copy","title":"obspec.Copy","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/copy/#obspec.Copy.copy","title":"copy","text":"<pre><code>copy(from_: str, to: str, *, overwrite: bool = True) -&gt; None\n</code></pre> <p>Copy an object from one path to another in the same object store.</p> <p>Parameters:</p> <ul> <li> <code>from_</code>               (<code>str</code>)           \u2013            <p>Source path</p> </li> <li> <code>to</code>               (<code>str</code>)           \u2013            <p>Destination path</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>overwrite</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, if there exists an object at the destination, it will     be overwritten.</p> <p>If <code>False</code>: will copy only if destination is empty. Performs an atomic operation if the underlying object storage supports it. If atomic operations are not supported by the underlying object storage (like S3) it will return an error.</p> <p>Will return an error if the destination already has an object.</p> </li> </ul>"},{"location":"api/copy/#obspec.CopyAsync","title":"obspec.CopyAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/copy/#obspec.CopyAsync.copy_async","title":"copy_async  <code>async</code>","text":"<pre><code>copy_async(from_: str, to: str, *, overwrite: bool = True) -&gt; None\n</code></pre> <p>Call <code>copy</code> asynchronously.</p> <p>Refer to the documentation for Copy.</p>"},{"location":"api/delete/","title":"Delete","text":""},{"location":"api/delete/#obspec.Delete","title":"obspec.Delete","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/delete/#obspec.Delete.delete","title":"delete","text":"<pre><code>delete(paths: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete the object at the specified location(s).</p> <p>Parameters:</p> <ul> <li> <code>paths</code>               (<code>str | Sequence[str]</code>)           \u2013            <p>The path or paths within the store to delete.</p> <p>When supported by the underlying store, this method will use bulk operations that delete more than one object per a request.</p> <p>If the object did not exist, the result may be an error or a success, depending on the behavior of the underlying store. For example, local filesystems, GCP, and Azure return an error, while S3 and in-memory will return Ok.</p> </li> </ul>"},{"location":"api/delete/#obspec.DeleteAsync","title":"obspec.DeleteAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/delete/#obspec.DeleteAsync.delete_async","title":"delete_async  <code>async</code>","text":"<pre><code>delete_async(paths: str | Sequence[str]) -&gt; None\n</code></pre> <p>Call <code>delete</code> asynchronously.</p> <p>Refer to the documentation for Delete.</p>"},{"location":"api/exceptions/","title":"Exceptions","text":""},{"location":"api/exceptions/#obspec.exceptions","title":"obspec.exceptions","text":"<p>Common exceptions.</p> <p>Users writing generic code with obspec may wish to catch common exceptions. For example, a user might wish to perform a head request but allow for the case where the object does not exist.</p> <p>Common exceptions pose a challenge for obspec. In general obspec strives to use structural subtyping (protocols) rather than nominal subtyping (subclassing). This is because protocols allow for implementations to have no knowledge of or dependency on a shared base library (obspec) while still being able to use the same interface.</p> <p>However, structural subtyping does not work for exceptions: when you use <code>except Exception</code>, that uses an <code>isinstance</code> check under the hood.</p> <p>As a workaround, we define well-known names for exceptions and expect external implementations to use the same names.</p>"},{"location":"api/exceptions/#obspec.exceptions--obspec-users","title":"Obspec users","text":"<p>Use the <code>map_exception</code> function in this module to convert from an implementation-defined exception to an obspec-defined exception.</p> <pre><code>from obspec import Head\nfrom obspec.exceptions import NotFoundError, map_exception\n\n\ndef check_if_exists(client: Head, path: str) -&gt; bool:\n    \"\"\"Check if a file exists at the given location.\n\n    Returns True if the file exists, False otherwise.\n    \"\"\"\n    try:\n        client.head(path)\n    except Exception as e:\n        if isinstance(map_exception(e), NotFoundError):\n            return False\n\n        raise\n\n    return True\n</code></pre> <p>Note</p> <p>If you don't care about catching exceptions, you can ignore this module entirely.</p>"},{"location":"api/exceptions/#obspec.exceptions--obspec-implementors","title":"Obspec implementors","text":"<p>Create your own exceptions but ensure you use the same names for your own exceptions as defined in this module.</p> <p>You may also have other exceptions that are not defined here, but any exceptions that logically fall under the purview of the exceptions defined here should your exceptions with the same name.</p>"},{"location":"api/exceptions/#obspec.exceptions.ExceptionType","title":"ExceptionType  <code>module-attribute</code>","text":"<pre><code>ExceptionType = TypeVar('ExceptionType', bound=Exception)\n</code></pre> <p>Type variable for an exception type, bound to <code>Exception</code>.</p>"},{"location":"api/exceptions/#obspec.exceptions.AlreadyExistsError","title":"AlreadyExistsError","text":"<p>               Bases: <code>BaseError</code></p> <p>Error when the object already exists.</p>"},{"location":"api/exceptions/#obspec.exceptions.BaseError","title":"BaseError","text":"<p>               Bases: <code>Exception</code></p> <p>The base obspec exception from which all other errors subclass.</p>"},{"location":"api/exceptions/#obspec.exceptions.InvalidPathError","title":"InvalidPathError","text":"<p>               Bases: <code>BaseError</code></p> <p>Error for invalid path.</p>"},{"location":"api/exceptions/#obspec.exceptions.NotFoundError","title":"NotFoundError","text":"<p>               Bases: <code>FileNotFoundError</code>, <code>BaseError</code></p> <p>Error when the object is not found at given location.</p>"},{"location":"api/exceptions/#obspec.exceptions.NotImplementedError","title":"NotImplementedError","text":"<p>               Bases: <code>BaseError</code>, <code>NotImplementedError</code></p> <p>Error when an operation is not implemented.</p> <p>Subclasses from the built-in NotImplementedError.</p>"},{"location":"api/exceptions/#obspec.exceptions.NotModifiedError","title":"NotModifiedError","text":"<p>               Bases: <code>BaseError</code></p> <p>Error when the object at the location isn't modified.</p>"},{"location":"api/exceptions/#obspec.exceptions.NotSupportedError","title":"NotSupportedError","text":"<p>               Bases: <code>BaseError</code></p> <p>Error when the attempted operation is not supported.</p>"},{"location":"api/exceptions/#obspec.exceptions.PermissionDeniedError","title":"PermissionDeniedError","text":"<p>               Bases: <code>BaseError</code></p> <p>Error when the used credentials don't have enough permission to perform the requested operation.</p>"},{"location":"api/exceptions/#obspec.exceptions.PreconditionError","title":"PreconditionError","text":"<p>               Bases: <code>BaseError</code></p> <p>Error when the required conditions failed for the operation.</p>"},{"location":"api/exceptions/#obspec.exceptions.UnauthenticatedError","title":"UnauthenticatedError","text":"<p>               Bases: <code>BaseError</code></p> <p>Error when the used credentials lack valid authentication.</p>"},{"location":"api/exceptions/#obspec.exceptions.map_exception","title":"map_exception","text":"<pre><code>map_exception(exception: ExceptionType) -&gt; ExceptionType | BaseError\n</code></pre> <p>Map an implementation-defined exception to an obspec-defined exception by name.</p> <p>This will use the name of the exception class to find a corresponding obspec-defined exception class. If no mapping is found, the original exception is returned.</p>"},{"location":"api/get/","title":"Get","text":""},{"location":"api/get/#obspec.Get","title":"obspec.Get","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.Get.get","title":"get","text":"<pre><code>get(path: str, *, options: GetOptions | None = None) -&gt; GetResult\n</code></pre> <p>Return the bytes that are stored at the specified location.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to retrieve.</p> </li> <li> <code>options</code>               (<code>GetOptions | None</code>, default:                   <code>None</code> )           \u2013            <p>options for accessing the file. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GetResult</code>           \u2013            <p>GetResult</p> </li> </ul>"},{"location":"api/get/#obspec.GetAsync","title":"obspec.GetAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.GetAsync.get_async","title":"get_async  <code>async</code>","text":"<pre><code>get_async(path: str, *, options: GetOptions | None = None) -&gt; GetResultAsync\n</code></pre> <p>Call <code>get</code> asynchronously.</p> <p>Refer to the documentation for Get.</p>"},{"location":"api/get/#obspec.GetRange","title":"obspec.GetRange","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.GetRange.get_range","title":"get_range","text":"<pre><code>get_range(\n    path: str, *, start: int, end: int | None = None, length: int | None = None\n) -&gt; Buffer\n</code></pre> <p>Return the bytes stored at the specified location in the given byte range.</p> <p>If the given range is zero-length or starts after the end of the object, an error will be returned. Additionally, if the range ends after the end of the object, the entire remainder of the object will be returned. Otherwise, the exact requested range will be returned.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to retrieve.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>start</code>               (<code>int</code>)           \u2013            <p>The start of the byte range.</p> </li> <li> <code>end</code>               (<code>int | None</code>)           \u2013            <p>The end of the byte range (exclusive). Either <code>end</code> or <code>length</code> must be non-None.</p> </li> <li> <code>length</code>               (<code>int | None</code>)           \u2013            <p>The number of bytes of the byte range. Either <code>end</code> or <code>length</code> must be non-None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Buffer</code>           \u2013            <p>A <code>Buffer</code> object implementing the Python buffer protocol.</p> </li> </ul>"},{"location":"api/get/#obspec.GetRangeAsync","title":"obspec.GetRangeAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.GetRangeAsync.get_range_async","title":"get_range_async  <code>async</code>","text":"<pre><code>get_range_async(\n    path: str, *, start: int, end: int | None = None, length: int | None = None\n) -&gt; Buffer\n</code></pre> <p>Call <code>get_range</code> asynchronously.</p> <p>Refer to the documentation for GetRange.</p>"},{"location":"api/get/#obspec.GetRanges","title":"obspec.GetRanges","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.GetRanges.get_ranges","title":"get_ranges","text":"<pre><code>get_ranges(\n    path: str,\n    *,\n    starts: Sequence[int],\n    ends: Sequence[int] | None = None,\n    lengths: Sequence[int] | None = None,\n) -&gt; Sequence[Buffer]\n</code></pre> <p>Return the bytes stored at the specified location in the given byte ranges.</p> <p>The choice of how to implement multiple range requests is implementation specific.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to retrieve.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>starts</code>               (<code>Sequence[int]</code>)           \u2013            <p>A sequence of <code>int</code> where each offset starts.</p> </li> <li> <code>ends</code>               (<code>Sequence[int] | None</code>)           \u2013            <p>A sequence of <code>int</code> where each offset ends (exclusive). Either <code>ends</code> or <code>lengths</code> must be non-None.</p> </li> <li> <code>lengths</code>               (<code>Sequence[int] | None</code>)           \u2013            <p>A sequence of <code>int</code> with the number of bytes of each byte range. Either <code>ends</code> or <code>lengths</code> must be non-None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Sequence[Buffer]</code>           \u2013            <p>A sequence of <code>Buffer</code>, one for each range, each implementing the Python</p> </li> <li> <code>Sequence[Buffer]</code>           \u2013            <p>buffer protocol.</p> </li> </ul>"},{"location":"api/get/#obspec.GetRangesAsync","title":"obspec.GetRangesAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.GetRangesAsync.get_ranges_async","title":"get_ranges_async  <code>async</code>","text":"<pre><code>get_ranges_async(\n    path: str,\n    *,\n    starts: Sequence[int],\n    ends: Sequence[int] | None = None,\n    lengths: Sequence[int] | None = None,\n) -&gt; Sequence[Buffer]\n</code></pre> <p>Call <code>get_ranges</code> asynchronously.</p> <p>Refer to the documentation for GetRanges.</p>"},{"location":"api/get/#obspec.GetOptions","title":"obspec.GetOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options for a get request.</p> <p>All options are optional.</p>"},{"location":"api/get/#obspec.GetOptions.head","title":"head  <code>instance-attribute</code>","text":"<pre><code>head: bool\n</code></pre> <p>Request transfer of no content</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-head</p>"},{"location":"api/get/#obspec.GetOptions.if_match","title":"if_match  <code>instance-attribute</code>","text":"<pre><code>if_match: str | None\n</code></pre> <p>Request will succeed if the <code>ObjectMeta::e_tag</code> matches.</p> <p>See datatracker.ietf.org/doc/html/rfc9110#name-if-match</p> <p>Examples:</p> <pre><code>If-Match: \"xyzzy\"\nIf-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-Match: *\n</code></pre>"},{"location":"api/get/#obspec.GetOptions.if_modified_since","title":"if_modified_since  <code>instance-attribute</code>","text":"<pre><code>if_modified_since: datetime | None\n</code></pre> <p>Request will succeed if the object has not been modified since.</p> <p>Some stores, such as S3, will only return <code>NotModified</code> for exact timestamp matches, instead of for any timestamp greater than or equal.</p> <p>datatracker.ietf.org/doc/html/rfc9110#section-13.1.4</p>"},{"location":"api/get/#obspec.GetOptions.if_none_match","title":"if_none_match  <code>instance-attribute</code>","text":"<pre><code>if_none_match: str | None\n</code></pre> <p>Request will succeed if the <code>ObjectMeta::e_tag</code> does not match.</p> <p>See datatracker.ietf.org/doc/html/rfc9110#section-13.1.2</p> <p>Examples:</p> <pre><code>If-None-Match: \"xyzzy\"\nIf-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-None-Match: *\n</code></pre>"},{"location":"api/get/#obspec.GetOptions.if_unmodified_since","title":"if_unmodified_since  <code>instance-attribute</code>","text":"<pre><code>if_unmodified_since: datetime | None\n</code></pre> <p>Request will succeed if the object has been modified since</p> <p>datatracker.ietf.org/doc/html/rfc9110#section-13.1.3</p>"},{"location":"api/get/#obspec.GetOptions.range","title":"range  <code>instance-attribute</code>","text":"<pre><code>range: tuple[int, int] | Sequence[int] | OffsetRange | SuffixRange\n</code></pre> <p>Request transfer of only the specified range of bytes.</p> <p>The semantics of this attribute are:</p> <ul> <li> <p><code>(int, int)</code>: Request a specific range of bytes <code>(start, end)</code>.</p> <p>If the given range is zero-length or starts after the end of the object, an error will be returned. Additionally, if the range ends after the end of the object, the entire remainder of the object will be returned. Otherwise, the exact requested range will be returned.</p> <p>The <code>end</code> offset is exclusive.</p> </li> <li> <p><code>{\"offset\": int}</code>: Request all bytes starting from a given byte offset.</p> <p>This is equivalent to <code>bytes={int}-</code> as an HTTP header.</p> </li> <li> <p><code>{\"suffix\": int}</code>: Request the last <code>int</code> bytes. Note that here, <code>int</code> is the     size of the request, not the byte offset. This is equivalent to <code>bytes=-{int}</code>     as an HTTP header.</p> </li> </ul> <p>datatracker.ietf.org/doc/html/rfc9110#name-range</p>"},{"location":"api/get/#obspec.GetOptions.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>Request a particular object version</p>"},{"location":"api/get/#obspec.GetResult","title":"obspec.GetResult","text":"<p>               Bases: <code>Iterable[Buffer]</code>, <code>Protocol</code></p> <p>Result for a get request.</p> <p>You can materialize the entire buffer by calling the <code>buffer</code> method or you can stream the result by iterating over it .</p> <p>Example:</p> <pre><code>from obspec import Get\n\ndef streaming_download(client: Get, path: str):\n    resp = client.get(path)\n    for buffer in resp:\n        print(len(memoryview(buffer)))\n</code></pre>"},{"location":"api/get/#obspec.GetResult.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: Attributes\n</code></pre> <p>Additional object attributes.</p>"},{"location":"api/get/#obspec.GetResult.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: ObjectMeta\n</code></pre> <p>The ObjectMeta for this object.</p>"},{"location":"api/get/#obspec.GetResult.range","title":"range  <code>property</code>","text":"<pre><code>range: tuple[int, int]\n</code></pre> <p>The range of bytes returned by this request.</p> <p>Note that this is <code>(start, stop)</code> not <code>(start, length)</code>.</p>"},{"location":"api/get/#obspec.GetResult.buffer","title":"buffer","text":"<pre><code>buffer() -&gt; Buffer\n</code></pre> <p>Collect the data into a <code>Buffer</code> object.</p> <p>This implements the Python buffer protocol. You can copy the buffer to Python memory by passing to <code>bytes</code>.</p>"},{"location":"api/get/#obspec.GetResultAsync","title":"obspec.GetResultAsync","text":"<p>               Bases: <code>AsyncIterable[Buffer]</code>, <code>Protocol</code></p> <p>Result for an async get request.</p> <p>You can materialize the entire buffer by calling the <code>buffer_async</code> method or you can stream the result by asynchronously iterating over it.</p> <p>Example:</p> <pre><code>from obspec import GetAsync\n\nasync def streaming_download(obs: GetAsync, path: str):\n    resp = await client.get_async(path)\n    async for buffer in resp:\n        print(len(memoryview(buffer)))\n</code></pre>"},{"location":"api/get/#obspec.GetResultAsync.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: Attributes\n</code></pre> <p>Additional object attributes.</p>"},{"location":"api/get/#obspec.GetResultAsync.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: ObjectMeta\n</code></pre> <p>The ObjectMeta for this object.</p>"},{"location":"api/get/#obspec.GetResultAsync.range","title":"range  <code>property</code>","text":"<pre><code>range: tuple[int, int]\n</code></pre> <p>The range of bytes returned by this request.</p> <p>Note that this is <code>(start, stop)</code> not <code>(start, length)</code>.</p>"},{"location":"api/get/#obspec.GetResultAsync.buffer_async","title":"buffer_async  <code>async</code>","text":"<pre><code>buffer_async() -&gt; Buffer\n</code></pre> <p>Collect the data into a <code>Buffer</code> object.</p> <p>This implements the Python buffer protocol. You can copy the buffer to Python memory by passing to <code>bytes</code>.</p>"},{"location":"api/get/#obspec.OffsetRange","title":"obspec.OffsetRange","text":"<p>               Bases: <code>TypedDict</code></p> <p>Request all bytes starting from a given byte offset.</p>"},{"location":"api/get/#obspec.OffsetRange.offset","title":"offset  <code>instance-attribute</code>","text":"<pre><code>offset: int\n</code></pre> <p>The byte offset for the offset range request.</p>"},{"location":"api/get/#obspec.SuffixRange","title":"obspec.SuffixRange","text":"<p>               Bases: <code>TypedDict</code></p> <p>Request up to the last <code>n</code> bytes.</p>"},{"location":"api/get/#obspec.SuffixRange.suffix","title":"suffix  <code>instance-attribute</code>","text":"<pre><code>suffix: int\n</code></pre> <p>The number of bytes from the suffix to request.</p>"},{"location":"api/head/","title":"Head","text":""},{"location":"api/head/#obspec.Head","title":"obspec.Head","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/head/#obspec.Head.head","title":"head","text":"<pre><code>head(path: str) -&gt; ObjectMeta\n</code></pre> <p>Return the metadata for the specified location.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ObjectMeta</code>           \u2013            <p>ObjectMeta</p> </li> </ul>"},{"location":"api/head/#obspec.HeadAsync","title":"obspec.HeadAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/head/#obspec.HeadAsync.head_async","title":"head_async  <code>async</code>","text":"<pre><code>head_async(path: str) -&gt; ObjectMeta\n</code></pre> <p>Call <code>head</code> asynchronously.</p> <p>Refer to the documentation for Head.</p>"},{"location":"api/list/","title":"List","text":""},{"location":"api/list/#obspec.List","title":"obspec.List","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/list/#obspec.List.list","title":"list","text":"<pre><code>list(\n    prefix: str | None = None, *, offset: str | None = None\n) -&gt; Iterator[Sequence[ObjectMeta]]\n</code></pre> <p>List all the objects with the given prefix.</p> <p>Prefixes are evaluated on a path segment basis, i.e. <code>foo/bar/</code> is a prefix of <code>foo/bar/x</code> but not of <code>foo/bar_baz/x</code>. List is recursive, i.e. <code>foo/bar/more/x</code> will be included.</p> <p>Examples:</p> <p>Synchronously iterate through list results:</p> <pre><code>import obspec\n\ndef upload_files(client: obspec.Put):\n    for i in range(100):\n        client.put(f\"file{i}.txt\", b\"foo\")\n\ndef list_files(client: obspec.List):\n    stream = client.list()\n    for list_result in stream:\n        print(list_result[0])\n        # {'path': 'file0.txt', 'last_modified': datetime.datetime(2024, 10, 23, 19, 19, 28, 781723, tzinfo=datetime.timezone.utc), 'size': 3, 'e_tag': '0', 'version': None}\n        break\n</code></pre> <p>Note</p> <p>The order of returned <code>ObjectMeta</code> is not guaranteed</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix within the store to use for listing. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>offset</code>               (<code>str | None</code>)           \u2013            <p>If provided, list all the objects with the given prefix and a location greater than <code>offset</code>. Defaults to <code>None</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Sequence[ObjectMeta]]</code>           \u2013            <p>A ListIterator, which you can iterate through to access list results.</p> </li> </ul>"},{"location":"api/list/#obspec.ListAsync","title":"obspec.ListAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/list/#obspec.ListAsync.list_async","title":"list_async","text":"<pre><code>list_async(\n    prefix: str | None = None, *, offset: str | None = None\n) -&gt; AsyncIterator[Sequence[ObjectMeta]]\n</code></pre> <p>List all the objects with the given prefix.</p> <p>Note that this method itself is not async. It's a synchronous method but returns an async iterator.</p> <p>Refer to obspec.List for more information about list semantics.</p> <p>Examples:</p> <p>Asynchronously iterate through list results. Just change <code>for</code> to <code>async for</code>:</p> <pre><code>stream = obs.list_async(store)\nasync for list_result in stream:\n    print(list_result[2])\n    # {'path': 'file10.txt', 'last_modified': datetime.datetime(2024, 10, 23, 19, 21, 46, 224725, tzinfo=datetime.timezone.utc), 'size': 3, 'e_tag': '10', 'version': None}\n    break\n</code></pre> <p>Note</p> <p>The order of returned <code>ObjectMeta</code> is not guaranteed</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix within the store to use for listing. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>offset</code>               (<code>str | None</code>)           \u2013            <p>If provided, list all the objects with the given prefix and a location greater than <code>offset</code>. Defaults to <code>None</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[Sequence[ObjectMeta]]</code>           \u2013            <p>A ListStream, which you can iterate through to access list results.</p> </li> </ul>"},{"location":"api/list/#obspec.ListWithDelimiter","title":"obspec.ListWithDelimiter","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/list/#obspec.ListWithDelimiter.list_with_delimiter","title":"list_with_delimiter","text":"<pre><code>list_with_delimiter(\n    prefix: str | None = None,\n) -&gt; ListResult[Sequence[ObjectMeta]]\n</code></pre> <p>List objects with the given prefix and an implementation specific delimiter.</p> <p>Returns common prefixes (directories) in addition to object metadata.</p> <p>Prefixes are evaluated on a path segment basis, i.e. <code>foo/bar/</code> is a prefix of <code>foo/bar/x</code> but not of <code>foo/bar_baz/x</code>. This list is not recursive, i.e. <code>foo/bar/more/x</code> will not be included.</p> <p>Note</p> <p>Any prefix supplied to this <code>prefix</code> parameter will not be stripped off the paths in the result.</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix within the store to use for listing. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ListResult[Sequence[ObjectMeta]]</code>           \u2013            <p>ListResult</p> </li> </ul>"},{"location":"api/list/#obspec.ListWithDelimiterAsync","title":"obspec.ListWithDelimiterAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/list/#obspec.ListWithDelimiterAsync.list_with_delimiter_async","title":"list_with_delimiter_async  <code>async</code>","text":"<pre><code>list_with_delimiter_async(\n    prefix: str | None = None,\n) -&gt; ListResult[Sequence[ObjectMeta]]\n</code></pre> <p>Call <code>list_with_delimiter</code> asynchronously.</p> <p>Refer to the documentation for ListWithDelimiter.</p>"},{"location":"api/list/#obspec.ListResult","title":"obspec.ListResult","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[ListChunkType_co]</code></p> <p>Result of a <code>list_with_delimiter</code> call.</p> <p>Includes objects, prefixes (directories) and a token for the next set of results. Individual result sets may be limited to 1,000 objects based on the underlying object storage's limitations.</p>"},{"location":"api/list/#obspec.ListResult.common_prefixes","title":"common_prefixes  <code>instance-attribute</code>","text":"<pre><code>common_prefixes: Sequence[str]\n</code></pre> <p>Prefixes that are common (like directories)</p>"},{"location":"api/list/#obspec.ListResult.objects","title":"objects  <code>instance-attribute</code>","text":"<pre><code>objects: ListChunkType_co\n</code></pre> <p>Object metadata for the listing</p>"},{"location":"api/list/#obspec.ListChunkType_co","title":"obspec.ListChunkType_co  <code>module-attribute</code>","text":"<pre><code>ListChunkType_co = TypeVar('ListChunkType_co', covariant=True)\n</code></pre> <p>The data structure used for holding list results.</p>"},{"location":"api/meta/","title":"Meta","text":""},{"location":"api/meta/#obspec.ObjectMeta","title":"obspec.ObjectMeta","text":"<p>               Bases: <code>TypedDict</code></p> <p>The metadata that describes an object.</p>"},{"location":"api/meta/#obspec.ObjectMeta.e_tag","title":"e_tag  <code>instance-attribute</code>","text":"<pre><code>e_tag: str | None\n</code></pre> <p>The unique identifier for the object</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-etag</p>"},{"location":"api/meta/#obspec.ObjectMeta.last_modified","title":"last_modified  <code>instance-attribute</code>","text":"<pre><code>last_modified: datetime\n</code></pre> <p>The last modified time</p>"},{"location":"api/meta/#obspec.ObjectMeta.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre> <p>The full path to the object</p>"},{"location":"api/meta/#obspec.ObjectMeta.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The size in bytes of the object</p>"},{"location":"api/meta/#obspec.ObjectMeta.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>A version indicator for this object</p>"},{"location":"api/put/","title":"Put","text":""},{"location":"api/put/#obspec.Put","title":"obspec.Put","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/put/#obspec.Put.put","title":"put","text":"<pre><code>put(\n    path: str,\n    file: IO[bytes]\n    | Path\n    | bytes\n    | Buffer\n    | Iterator[Buffer]\n    | Iterable[Buffer],\n    *,\n    attributes: Attributes | None = None,\n    tags: dict[str, str] | None = None,\n    mode: PutMode | None = None,\n    use_multipart: bool | None = None,\n    chunk_size: int = ...,\n    max_concurrency: int = ...,\n) -&gt; PutResult\n</code></pre> <p>Save the provided bytes to the specified location.</p> <p>The operation is guaranteed to be atomic, it will either successfully write the entirety of <code>file</code> to <code>location</code>, or fail. No clients should be able to observe a partially written object.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store for where to save the file.</p> </li> <li> <code>file</code>               (<code>IO[bytes] | Path | bytes | Buffer | Iterator[Buffer] | Iterable[Buffer]</code>)           \u2013            <p>The object to upload. Supports various input:</p> <ul> <li>A file-like object opened in binary read mode</li> <li>A <code>Path</code> to a local file</li> <li>A <code>bytes</code> object.</li> <li>Any object implementing the Python buffer protocol (includes <code>bytes</code> but also <code>memoryview</code>, numpy arrays, and more).</li> <li>An iterator or iterable of objects implementing the Python buffer protocol.</li> </ul> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>mode</code>               (<code>PutMode | None</code>)           \u2013            <p>Configure the <code>PutMode</code> for this operation. Refer to the <code>PutMode</code> docstring for more information.</p> <p>If this provided and is not <code>\"overwrite\"</code>, a non-multipart upload will be performed. Defaults to <code>\"overwrite\"</code>.</p> </li> <li> <code>attributes</code>               (<code>Attributes | None</code>)           \u2013            <p>Provide a set of <code>Attributes</code>. Defaults to <code>None</code>.</p> </li> <li> <code>tags</code>               (<code>dict[str, str] | None</code>)           \u2013            <p>Provide tags for this object. Defaults to <code>None</code>.</p> </li> <li> <code>use_multipart</code>               (<code>bool | None</code>)           \u2013            <p>Whether to force using a multipart upload.</p> <p>If <code>True</code>, the upload will always use a multipart upload, even if the length of the file is less than <code>chunk_size</code>. If <code>False</code>, the upload will never use a multipart upload, and the entire input will be materialized in memory as part of the upload. If <code>None</code>, the implementation will choose whether to use a multipart upload based on the length of the file and <code>chunk_size</code>.</p> <p>Defaults to <code>None</code>.</p> </li> <li> <code>chunk_size</code>               (<code>int</code>)           \u2013            <p>The size of chunks to use within each part of the multipart upload. The default is allowed to be implementation-specific.</p> </li> <li> <code>max_concurrency</code>               (<code>int</code>)           \u2013            <p>The maximum number of chunks to upload concurrently. This impacts the memory usage of large file uploads. The default is allowed to be implementation-specific.</p> </li> </ul>"},{"location":"api/put/#obspec.PutAsync","title":"obspec.PutAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/put/#obspec.PutAsync.put_async","title":"put_async  <code>async</code>","text":"<pre><code>put_async(\n    path: str,\n    file: IO[bytes]\n    | Path\n    | bytes\n    | Buffer\n    | AsyncIterator[Buffer]\n    | AsyncIterable[Buffer]\n    | Iterator[Buffer]\n    | Iterable[Buffer],\n    *,\n    attributes: Attributes | None = None,\n    tags: dict[str, str] | None = None,\n    mode: PutMode | None = None,\n    use_multipart: bool | None = None,\n    chunk_size: int = ...,\n    max_concurrency: int = ...,\n) -&gt; PutResult\n</code></pre> <p>Call <code>put</code> asynchronously.</p> <p>Refer to the documentation for <code>Put</code>. In addition to what the synchronous <code>put</code> allows for the <code>file</code> parameter, this also supports an async iterator or iterable of objects implementing the Python buffer protocol.</p> <p>This means, for example, you can pass the result of <code>get_async</code> directly to <code>put_async</code>, and the request will be streamed through Python during the put operation:</p> <pre><code>from obspec import GetAsync, PutAsync\n\nasync def streaming_copy(\n    fetch_client: GetAsync,\n    put_client: PutAsync,\n    path1: str,\n    path2: str,\n):\n    # This only constructs the stream, it doesn't materialize the data in memory\n    resp = await fetch_client.get_async(path1)\n    # A streaming upload is created to copy the file to path2\n    await put_client.put_async(path2, resp)\n</code></pre>"},{"location":"api/put/#obspec.PutResult","title":"obspec.PutResult","text":"<p>               Bases: <code>TypedDict</code></p> <p>Result for a put request.</p>"},{"location":"api/put/#obspec.PutResult.e_tag","title":"e_tag  <code>instance-attribute</code>","text":"<pre><code>e_tag: str | None\n</code></pre> <p>The unique identifier for the newly created object</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-etag</p>"},{"location":"api/put/#obspec.PutResult.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>A version indicator for the newly created object.</p>"},{"location":"api/put/#obspec.UpdateVersion","title":"obspec.UpdateVersion","text":"<p>               Bases: <code>TypedDict</code></p> <p>Uniquely identifies a version of an object to update.</p> <p>Stores will use differing combinations of <code>e_tag</code> and <code>version</code> to provide conditional updates, and it is therefore recommended applications preserve both</p>"},{"location":"api/put/#obspec.UpdateVersion.e_tag","title":"e_tag  <code>instance-attribute</code>","text":"<pre><code>e_tag: str | None\n</code></pre> <p>The unique identifier for the newly created object.</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-etag</p>"},{"location":"api/put/#obspec.UpdateVersion.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>A version indicator for the newly created object.</p>"},{"location":"api/put/#obspec.PutMode","title":"obspec.PutMode  <code>module-attribute</code>","text":"<pre><code>PutMode: TypeAlias = Union[Literal['create', 'overwrite'], UpdateVersion]\n</code></pre> <p>Configure preconditions for the put operation</p> <p>There are three modes:</p> <ul> <li>Overwrite: Perform an atomic write operation, overwriting any object present at the   provided path.</li> <li>Create: Perform an atomic write operation, returning   an error if an object already exists at the provided path.</li> <li>Update: Perform an atomic write operation if the current version of the object matches   the provided <code>UpdateVersion</code>, returning an error otherwise.</li> </ul> <p>If a string is provided, it must be one of:</p> <ul> <li><code>\"overwrite\"</code></li> <li><code>\"create\"</code></li> </ul> <p>If a <code>dict</code> is provided, it must meet the criteria of <code>UpdateVersion</code>.</p>"},{"location":"api/rename/","title":"Rename","text":""},{"location":"api/rename/#obspec.Rename","title":"obspec.Rename","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/rename/#obspec.Rename.rename","title":"rename","text":"<pre><code>rename(from_: str, to: str, *, overwrite: bool = True) -&gt; None\n</code></pre> <p>Move an object from one path to another in the same object store.</p> <p>By default, this is implemented as a copy and then delete source. It may not check when deleting source that it was the same object that was originally copied.</p> <p>Parameters:</p> <ul> <li> <code>from_</code>               (<code>str</code>)           \u2013            <p>Source path</p> </li> <li> <code>to</code>               (<code>str</code>)           \u2013            <p>Destination path</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>overwrite</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, if there exists an object at the destination, it will be overwritten. If <code>False</code>, will return an error if the destination already has an object.</p> </li> </ul>"},{"location":"api/rename/#obspec.RenameAsync","title":"obspec.RenameAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/rename/#obspec.RenameAsync.rename_async","title":"rename_async  <code>async</code>","text":"<pre><code>rename_async(from_: str, to: str, *, overwrite: bool = True) -&gt; None\n</code></pre> <p>Call <code>rename</code> asynchronously.</p> <p>Refer to the documentation for Rename.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/","title":"Introducing Obspec: A Python protocol for interfacing with object storage","text":"<p>Obspec defines a minimal, transparent Python interface to read, write, and modify data on object storage.</p> <p>It's designed to abstract away the complexities of different object storage providers while acknowledging that object storage is not a filesystem. The Python protocols present more similarities to HTTP requests than Python file objects.</p> <p>The primary existing Python specification used for object storage is fsspec, which defines a filesystem-like interface based around Python file-like objects.</p> <p>However this presents an impedance mismatch: object storage is not a filesystem and does not have the same semantics as filesystems. This leads to surprising behavior, poor performance, and integration complexity.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#file-like-stateful-apis-add-ambiguity","title":"File-like, stateful APIs add ambiguity","text":"<p>Fsspec has significant layers of caching to try to make object storage behave like a filesystem, but this also causes unpredictable results.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#fsspec-opaque-list-caching","title":"Fsspec: Opaque list caching","text":"<p>Take the following example. Is the list request cached? How many requests are made, one or two? What happens if the remote data changes? Will the second list automatically reflect new data?</p> <pre><code>from time import sleep\nfrom fsspec import AbstractFileSystem\n\ndef list_files_twice(fs: AbstractFileSystem):\n    fs.ls(\"s3://mybucket\")\n    sleep(5)\n    fs.ls(\"s3://mybucket\")\n</code></pre> <p>Because <code>AbstractFileSystem.ls</code> returns a fully-materialized <code>list</code> and there can be thousands of items in a bucket, fsspec implementations tend to use some sort of internal caching. Furthermore, the specification explicitly allows for caching by defining a keyword argument named <code>refresh</code>. But the API documentation for <code>ls</code> doesn't say what the default for <code>refresh</code> is (only that you may explicitly pass <code>refresh=True|False</code> to force a behavior).</p> <p>You have to read implementation-specific source code to find out that, in the case of <code>s3fs</code>, the fsspec implementation for S3, the default is <code>refresh=False</code>. So in the case of <code>s3fs</code>, the list call is cached, only one HTTP request is made, and the second call to <code>ls</code> will not reflect new data without an explicit call to <code>refresh=True</code>.</p> <p>But the design of the abstraction means that it's very difficult for generic code operating on the abstract base class to infer from the function signature how many HTTP requests will be made by most implementations.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#obstore-streaming-list","title":"Obstore: Streaming list","text":"<p>In contrast, obspec relies on iterators wherever possible. The <code>obspec.List</code> protocol returns an iterator of metadata about files, which enables stateless implementations that map much more closely to the underlying HTTP requests.</p> <pre><code>from time import sleep\nfrom obspec import List\n\ndef list_files_twice(client: List):\n    list_items = list(client.list(\"prefix\"))\n    sleep(5)\n    list_items = list(client.list(\"prefix\"))\n</code></pre> <p>There's no internal caching, a set of possibly-multiple requests are made for each call to <code>list</code>, and each call to <code>list</code> will reflect the latest state of the bucket.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#fsspec-opaque-file-downloads","title":"Fsspec: Opaque file downloads","text":"<p>Consider the options fsspec provides for downloading data. Fsspec doesn't have a method to stream a file download into memory, so your options are:</p> <ol> <li>Materialize the entire file in memory, which is not practical for large files.</li> <li>Make targeted range requests, which requires you to know the byte ranges you want to download and requires multiple HTTP calls.</li> <li>Use a file-like object, which is not clear how many HTTP requests it will make, and how caching works.</li> <li>Download to a local file, which incurs overhead of writing to disk and then reading back into memory.</li> </ol> <p>Suppose we choose option 3, using a file-like object. It's fully opaque how many requests are being made:</p> <pre><code>from fsspec import AbstractFileSystem\n\ndef iterate_over_file_object(fs: AbstractFileSystem, path: str):\n    with fs.open(path) as f:\n        for line in f:\n            print(line.strip())\n</code></pre>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#obspec-streaming-download","title":"Obspec: Streaming download","text":"<p>By mapping more closely to the underlying HTTP requests, obspec makes it clearer what HTTP requests are happening under the hood. [obspec.Get] allows for streaming a file download via a Python iterator:</p> <pre><code>from obspec import Get\n\ndef download_file(client: Get):\n    response = client.get(\"my-file.txt\")\n    for buffer in response:\n        # Process each buffer chunk as needed\n        print(f\"Received buffer of size: {len(memoryview(buffer))} bytes\")\n</code></pre> <p>In this case, only one HTTP request is made, and you can start processing the data as it arrives without needing to materialize the entire file in memory.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#support-for-functionality-not-native-to-filesystems","title":"Support for functionality not native to filesystems","text":"<p>Obspec allows for functionality not native to filesystems, such as preconditions (fetch if unmodified) and atomic multipart uploads.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#native-async-support","title":"Native Async support","text":"<p>Fsspec was originally designed for synchronous I/O. Async support was bolted on via async versions of methods, but the core architecture is still sync-first and the async support is relatively sparsely documented.</p> <p>The async support in fsspec is intentionally hidden away: all async operations are named with a leading underscore and in effect \"private\" and not designed to be visible by most users. Additionally some \"async\" calls in fsspec just use <code>loop.run_in_executor(...)</code> to perform the work in a thread in the background.</p> <p>In 2025, the Python async ecosystem has progressed to the point where an interface should provide first-class support for async code. All obspec functionality is defined in matching sync and async protocols with clear separation between the two.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#api-surface","title":"API Surface","text":"<p>The fsspec API surface is quite large. <code>AbstractFileSystem</code> defines around 10 public attributes and 56 public methods. <code>AbstractBufferedFile</code> defines around 20 public methods. And that's not including the async implementation in <code>AsyncFileSystem</code>.</p> <p>Aside from being difficult for backends to implement the full surface area, it's also common to hit <code>NotImplementedError</code> at runtime when a backend doesn't support the method you're using.</p> <p>Obspec has a much smaller API surface than fsspec, which makes it easier to understand, implement, and compose. Obspec has just 10 core methods with synchronous and asynchronous variants:</p> <ul> <li><code>copy</code>/<code>copy_async</code>: Copy an object within the same store.</li> <li><code>delete</code>/<code>delete_async</code>: Delete an object.</li> <li><code>get</code>/<code>get_async</code>: Download a file, returning an iterator or async iterator of buffers.</li> <li><code>get_range</code>/<code>get_range_async</code>: Get a single byte range.</li> <li><code>get_ranges</code>/<code>get_ranges_async</code>: Get multiple byte ranges.</li> <li><code>head</code>/<code>head_async</code>: Access file metadata.</li> <li><code>list</code>/<code>list_async</code>: List objects, returning an iterator or async iterator of metadata.</li> <li><code>list_with_delimiter</code>/<code>list_with_delimiter_async</code>: List objects within a specific directory.</li> <li><code>put</code>/<code>put_async</code>: Upload a file, buffer, or iterable of buffers.</li> <li><code>rename</code>/<code>rename_async</code>: Move an object from one path to another within the same store.</li> </ul> <p>This smaller API surface also means that it's much rarer to get a runtime <code>NotImplementedError</code>.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#static-typing-support","title":"Static typing support","text":"<p>Fsspec hardly has any support for static typing, which makes it hard for a user to know they're using the interface correctly.</p> <p>Obspec is fully statically typed. This provides excellent in-editor documentation and autocompletion, as well as static warnings when the interface is used incorrectly.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#protocols-duck-typing-not-subclassing","title":"Protocols &amp; duck typing, not subclassing","text":"<p>Python defines two types of subtyping: nominal and structural subtyping.</p> <p>In essence, nominal subtyping means subclassing. Class <code>A</code> is a nominal subtype of class <code>B</code> if <code>A</code> subclasses from <code>B</code>. Structural subtyping means duck typing. Class <code>A</code> is a structural subtype of class <code>B</code> if <code>A</code> \"looks like\" <code>B</code>, that is, it conforms to the same shape as <code>B</code>.</p> <p>Using structural subtyping means that an ecosystem of libraries don't need to have any knowledge or dependency on each other, as long as they strictly and accurately implement the same duck-typed interface.</p> <p>For example, an <code>Iterable</code> is a protocol. You don't need to subclass from a base <code>Iterable</code> class in order to make your type iterable. Instead, if you define an <code>__iter__</code> dunder method on your class, it automatically becomes iterable because Python has a convention that if you see an <code>__iter__</code> method, you can call it to iterate over a sequence.</p> <p>As another example, the Buffer Protocol is a protocol to enable zero-copy exchange of binary data between Python libraries. Unlike <code>Iterable</code>, this is a protocol that is inaccessible in user Python code and only accessible at the C level, but it's still a protocol. Numpy can create arrays that view a buffer via the buffer protocol, even when Numpy has no prior knowledge of the library that produces the buffer.</p> <p>Obspec relies on structural subtyping to provide flexibility to implementors while not requiring them to take an explicit dependency on obspec, which would be required to subclass from obspec using nominal subtyping.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#existing-implementations","title":"Existing implementations","text":"<p>Obstore is the primary existing implementation of obspec. Indeed, obspec's API is essentially a simplified formalization of obstore's existing API.</p> <p>We'd like to see additional future first-party and third-party implementations of the obspec protocol.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#example-caching-wrapper","title":"Example: Caching wrapper","text":"<p>Obspec does not have any built-in caching logic. This is a deliberate design choice to keep the interface simple and predictable. Caching can be implemented as a wrapper around obspec, allowing users to choose their caching strategy without complicating the core interface.</p> <p>Here we have a very simple example of this approach. <code>SimpleCache</code> is a wrapper class around something implementing the <code>GetRange</code> protocol. The <code>SimpleCache</code> manages caching logic itself outside the underlying <code>GetRange</code> backend. But since <code>SimpleCache</code> also implements <code>GetRange</code>, it can be used wherever <code>GetRange</code> is expected.</p> <pre><code>from __future__ import annotations\nfrom typing_extensions import Buffer\nfrom obspec import GetRange\n\nclass SimpleCache(GetRange):\n    \"\"\"A simple cache for synchronous range requests that never evicts data.\"\"\"\n\n    def __init__(self, client: GetRange):\n        self.client = client\n        self.cache: dict[tuple[str, int, int | None, int | None], Buffer] = {}\n\n    def get_range(\n        self,\n        path: str,\n        *,\n        start: int,\n        end: int | None = None,\n        length: int | None = None,\n    ) -&gt; Buffer:\n        cache_key = (path, start, end, length)\n        if cache_key in self.cache:\n            return self.cache[cache_key]\n\n        response = self.client.get_range(\n            path,\n            start=start,\n            end=end,\n            length=length,\n        )\n        self.cache[cache_key] = response\n        return response\n</code></pre> <p>Of course, a real implementation would be smarter than just caching the exact byte range, and might use something like block caching.</p> <p>Now if <code>GetRange</code> is expected to be used like so:</p> <pre><code>def my_function(client: GetRange, path: str, *, start: int, end: int):\n    buffer = client.get_range(path, start=start, end=end)\n    # Do something with the buffer\n    print(len(memoryview(buffer)))\n</code></pre> <p>Then a user can seamlessly insert the <code>SimpleCache</code> in the middle. The second request will be cached and not reach the S3Store</p> <pre><code>from obstore.store import S3Store\n\nstore = S3Store(\"bucket\")\ncaching_wrapper = SimpleCache(store)\nmy_function(caching_wrapper, \"path.txt\", start=0, end=10)\nmy_function(caching_wrapper, \"path.txt\", start=0, end=10)\n</code></pre>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#usage-for-downstream-libraries","title":"Usage for downstream libraries","text":"<p>Not all backends will necessarily support all features. Obspec is defined as a set of independent protocols to allow libraries depending on obspec to verify that obspec implementations provide all required functionality.</p> <p>In particular, Python allows you to intersect protocols. Thus, you should use the most minimal methods required for your use case, creating your own subclassed protocol with just what you need.</p> <pre><code>from typing import Protocol\nfrom obspec import Delete, Get, List, Put\n\n\nclass MyCustomObspecProtocol(Delete, Get, List, Put, Protocol):\n    \"\"\"\n    My custom protocol with functionality required in a downstream library.\n    \"\"\"\n</code></pre> <p>Then use that protocol generically:</p> <pre><code>def do_something(backend: MyCustomObspecProtocol):\n    backend.put(\"path.txt\", b\"hello world!\")\n\n    files = list(backend.list())\n    assert any(file[\"path\"] == \"path.txt\" for file in files)\n\n    assert memoryview(backend.get(\"path.txt\").buffer()) == b\"hello world!\"\n\n    backend.delete(\"path.txt\")\n\n    files = list(backend.list())\n    assert not any(file[\"path\"] == \"path.txt\" for file in files)\n</code></pre> <p>By defining the most minimal interface you require, it widens the set of possible backends that can implement your interface. For example, making a range request is possible by any HTTP client, but a list call may have semantics not defined in the HTTP specification. So by only requiring, say, <code>Get</code> and <code>GetRange</code> you allow more implementations to be used with your program.</p> <p>Alternatively, if you only require a single method, there's no need to create your own custom protocol, and you can use the obspec protocol directly.</p>"},{"location":"blog/2025/06/25/introducing-obspec-a-python-protocol-for-interfacing-with-object-storage/#example-cloud-optimized-geotiff-reader","title":"Example: Cloud-Optimized GeoTIFF reader","text":"<p>A Cloud-Optimized GeoTIFF (COG) reader might only require range requests</p> <pre><code>from typing import Protocol\nfrom obspec import GetRange, GetRanges\n\nclass CloudOptimizedGeoTiffReader(GetRange, GetRanges, Protocol):\n    \"\"\"Protocol with necessary methods to read a Cloud-Optimized GeoTIFF file.\"\"\"\n\ndef read_cog_header(backend: CloudOptimizedGeoTiffReader, path: str):\n    # Make request for first 32KB of file\n    header_bytes = backend.get_range(path, start=0, end=32 * 1024)\n    # TODO: parse information from header\n    raise NotImplementedError\n\ndef read_cog_image(backend: CloudOptimizedGeoTiffReader, path: str):\n    header = read_cog_header(backend, path)\n    # TODO: read image data from file.\n</code></pre> <p>An async Cloud-Optimized GeoTIFF reader might instead subclass from obspec's async methods:</p> <pre><code>from typing import Protocol\nfrom obspec import GetRangeAsync, GetRangesAsync\n\nclass AsyncCloudOptimizedGeoTiffReader(GetRangeAsync, GetRangesAsync, Protocol):\n    \"\"\"Necessary methods to asynchronously read a Cloud-Optimized GeoTIFF file.\"\"\"\n\nasync def read_cog_header(backend: AsyncCloudOptimizedGeoTiffReader, path: str):\n    # Make request for first 32KB of file\n    header_bytes = await backend.get_range_async(path, start=0, end=32 * 1024)\n    # TODO: parse information from header\n    raise NotImplementedError\n\nasync def read_cog_image(backend: AsyncCloudOptimizedGeoTiffReader, path: str):\n    header = await read_cog_header(backend, path)\n    # TODO: read image data from file.\n</code></pre>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/release/","title":"Release","text":""}]}