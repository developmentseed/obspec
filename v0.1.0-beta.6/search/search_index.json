{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"obspec","text":"<p>Object storage protocol definitions for Python.</p>"},{"location":"#background","title":"Background","text":"<p>Python defines two types of subtyping: nominal and structural subtyping. In essence, nominal subtyping is subclassing. Class <code>A</code> is a nominal subtype of class <code>B</code> if <code>A</code> subclasses from <code>B</code>. Structural subtyping is duck typing. Class <code>A</code> is a structural subtype of class <code>B</code> if <code>A</code> \"looks like\" <code>B</code>, that is, it conforms to the same shape as <code>B</code>.</p> <p>Using structural subtyping means that an ecosystem of libraries don't need to have any knowledge or dependency on each other, as long as they strictly and accurately implement the same duck-typed interface.</p> <p>For example, an <code>Iterable</code> is a protocol. You don't need to subclass from a base <code>Iterable</code> class in order to make your type iterable. Instead, if you define an <code>__iter__</code> dunder method on your class, it automatically becomes iterable because Python has a convention that if you see an <code>__iter__</code> method, you can call it to iterate over a sequence.</p> <p>As another example, the Buffer Protocol is a protocol to enable zero-copy exchange of binary data between Python libraries. Unlike <code>Iterable</code>, this is a protocol that is inaccessible in user Python code and only accessible at the C level, but it's still a protocol. Numpy can create arrays that view a buffer via the buffer protocol, even when Numpy has no prior knowledge of the library that produces the buffer.</p> <p>Obspec defines core protocols to interface with data stored on file systems, remote object stores, etc.</p>"},{"location":"#usage","title":"Usage","text":"<p>You should use the minimal methods required for your use case, creating your own protocol with just what you need.</p> <p>In particular, Python allows you to intersect protocols:</p> <pre><code>from typing import Protocol\n\nfrom obspec import Delete, Get, List, Put\n\n\nclass MyCustomObspecProtocol(Delete, Get, List, Put, Protocol):\n    \"\"\"My custom protocol.\"\"\"\n</code></pre> <p>Then use that protocol generically:</p> <pre><code>def do_something(backend: MyCustomObspecProtocol):\n    backend.put(\"path.txt\", b\"hello world!\")\n\n    files = backend.list().collect()\n    assert any(file[\"path\"] == \"path.txt\" for file in files)\n\n    assert backend.get(\"path.txt\").bytes() == b\"hello world!\"\n\n    backend.delete(\"path.txt\")\n\n    files = backend.list().collect()\n    assert not any(file[\"path\"] == \"path.txt\" for file in files)\n</code></pre> <p>In particular, by defining the most minimal interface you require, it widens the set of possible backends that can implement your interface. For example, making a range request is possible by any HTTP client, but a list call may have semantics not defined in the HTTP specification. So by only requiring, say, <code>Get</code> and <code>GetRange</code> you allow more implementations to be used with your program.</p>"},{"location":"#example-cloud-optimized-geotiff-reader","title":"Example: Cloud-Optimized GeoTIFF reader","text":"<p>A Cloud-Optimized GeoTIFF (COG) reader might only require range requests</p> <pre><code>from typing import Protocol\n\nfrom obspec import GetRange, GetRanges\n\n\nclass CloudOptimizedGeoTiffReader(GetRange, GetRanges, Protocol):\n    \"\"\"Protocol with necessary methods to read a Cloud-Optimized GeoTIFF file.\"\"\"\n\n\ndef read_cog_header(backend: CloudOptimizedGeoTiffReader, path: str):\n    # Make request for first 32KB of file\n    header_bytes = backend.get_range(path, start=0, end=32 * 1024)\n\n    # TODO: parse information from header\n    raise NotImplementedError\n\n\ndef read_cog_image(backend: CloudOptimizedGeoTiffReader, path: str):\n    header = read_cog_header(backend, path)\n\n    # TODO: read image data from file.\n</code></pre> <p>An async Cloud-Optimized GeoTIFF reader might instead subclass from obspec's async methods:</p> <pre><code>from typing import Protocol\n\nfrom obspec import GetRangeAsync, GetRangesAsync\n\n\nclass AsyncCloudOptimizedGeoTiffReader(GetRangeAsync, GetRangesAsync, Protocol):\n    \"\"\"Necessary methods to asynchronously read a Cloud-Optimized GeoTIFF file.\"\"\"\n\n\nasync def read_cog_header(backend: AsyncCloudOptimizedGeoTiffReader, path: str):\n    # Make request for first 32KB of file\n    header_bytes = await backend.get_range_async(path, start=0, end=32 * 1024)\n\n    # TODO: parse information from header\n\n    raise NotImplementedError\n\n\nasync def read_cog_image(backend: AsyncCloudOptimizedGeoTiffReader, path: str):\n    header = await read_cog_header(backend, path)\n\n    # TODO: read image data from file.\n</code></pre>"},{"location":"#implementations","title":"Implementations","text":"<p>The primary implementation that implements obspec is obstore, and the obspec protocol was designed around the obstore API.</p>"},{"location":"#utilities","title":"Utilities","text":"<p>There are planned to be utilities that build on top of obspec. Potentially:</p> <ul> <li>globbing: an implementation of <code>glob()</code> similar to <code>fsspec.glob</code> that uses <code>obspec</code> primitives.</li> <li>Caching: wrappers around <code>Get</code>/<code>GetRange</code>/<code>GetRanges</code> that store a cache of bytes.</li> </ul> <p>By having these utilities operate on generic obspec protocols, it means that they can instantly be used with any future obspec backend.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#010-2025-xx-xx","title":"[0.1.0] - 2025-XX-XX","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"api/attributes/","title":"Attributes","text":""},{"location":"api/attributes/#obspec.Attribute","title":"obspec.Attribute  <code>module-attribute</code>","text":"<pre><code>Attribute: TypeAlias = Union[\n    Literal[\n        \"Content-Disposition\",\n        \"Content-Encoding\",\n        \"Content-Language\",\n        \"Content-Type\",\n        \"Cache-Control\",\n    ],\n    str,\n]\n</code></pre> <p>Additional object attribute types.</p> <ul> <li> <p><code>\"Content-Disposition\"</code>: Specifies how the object should be handled by a browser.</p> <p>See Content-Disposition.</p> </li> <li> <p><code>\"Content-Encoding\"</code>: Specifies the encodings applied to the object.</p> <p>See Content-Encoding.</p> </li> <li> <p><code>\"Content-Language\"</code>: Specifies the language of the object.</p> <p>See Content-Language.</p> </li> <li> <p><code>\"Content-Type\"</code>: Specifies the MIME type of the object.</p> <p>This takes precedence over any client configuration.</p> <p>See Content-Type.</p> </li> <li> <p><code>\"Cache-Control\"</code>: Overrides cache control policy of the object.</p> <p>See Cache-Control.</p> </li> </ul> <p>Any other string key specifies a user-defined metadata field for the object.</p>"},{"location":"api/attributes/#obspec.Attributes","title":"obspec.Attributes  <code>module-attribute</code>","text":"<pre><code>Attributes: TypeAlias = dict[Attribute, str]\n</code></pre> <p>Additional attributes of an object</p> <p>Attributes can be specified in <code>Put</code>/<code>PutAsync</code> and retrieved from <code>Get</code>/<code>GetAsync</code>.</p> <p>Unlike ObjectMeta, Attributes are not returned by listing APIs</p>"},{"location":"api/copy/","title":"Copy","text":""},{"location":"api/copy/#obspec.Copy","title":"obspec.Copy","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/copy/#obspec.Copy.copy","title":"copy","text":"<pre><code>copy(from_: str, to: str, *, overwrite: bool = True) -&gt; None\n</code></pre> <p>Copy an object from one path to another in the same object store.</p> <p>Parameters:</p> <ul> <li> <code>from_</code>               (<code>str</code>)           \u2013            <p>Source path</p> </li> <li> <code>to</code>               (<code>str</code>)           \u2013            <p>Destination path</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>overwrite</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, if there exists an object at the destination, it will     be overwritten.</p> <p>If <code>False</code>: will copy only if destination is empty. Performs an atomic operation if the underlying object storage supports it. If atomic operations are not supported by the underlying object storage (like S3) it will return an error.</p> <p>Will return an error if the destination already has an object.</p> </li> </ul>"},{"location":"api/copy/#obspec.CopyAsync","title":"obspec.CopyAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/copy/#obspec.CopyAsync.copy_async","title":"copy_async  <code>async</code>","text":"<pre><code>copy_async(from_: str, to: str, *, overwrite: bool = True) -&gt; None\n</code></pre> <p>Call <code>copy</code> asynchronously.</p> <p>Refer to the documentation for Copy.</p>"},{"location":"api/delete/","title":"Delete","text":""},{"location":"api/delete/#obspec.Delete","title":"obspec.Delete","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/delete/#obspec.Delete.delete","title":"delete","text":"<pre><code>delete(paths: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete the object at the specified location(s).</p> <p>Parameters:</p> <ul> <li> <code>paths</code>               (<code>str | Sequence[str]</code>)           \u2013            <p>The path or paths within the store to delete.</p> <p>When supported by the underlying store, this method will use bulk operations that delete more than one object per a request.</p> <p>If the object did not exist, the result may be an error or a success, depending on the behavior of the underlying store. For example, local filesystems, GCP, and Azure return an error, while S3 and in-memory will return Ok.</p> </li> </ul>"},{"location":"api/delete/#obspec.DeleteAsync","title":"obspec.DeleteAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/delete/#obspec.DeleteAsync.delete_async","title":"delete_async  <code>async</code>","text":"<pre><code>delete_async(paths: str | Sequence[str]) -&gt; None\n</code></pre> <p>Call <code>delete</code> asynchronously.</p> <p>Refer to the documentation for Delete.</p>"},{"location":"api/get/","title":"Get","text":""},{"location":"api/get/#obspec.Get","title":"obspec.Get","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.Get.get","title":"get","text":"<pre><code>get(path: str, *, options: GetOptions | None = None) -&gt; GetResult\n</code></pre> <p>Return the bytes that are stored at the specified location.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to retrieve.</p> </li> <li> <code>options</code>               (<code>GetOptions | None</code>, default:                   <code>None</code> )           \u2013            <p>options for accessing the file. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GetResult</code>           \u2013            <p>GetResult</p> </li> </ul>"},{"location":"api/get/#obspec.GetAsync","title":"obspec.GetAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.GetAsync.get_async","title":"get_async  <code>async</code>","text":"<pre><code>get_async(path: str, *, options: GetOptions | None = None) -&gt; GetResultAsync\n</code></pre> <p>Call <code>get</code> asynchronously.</p> <p>Refer to the documentation for Get.</p>"},{"location":"api/get/#obspec.GetRange","title":"obspec.GetRange","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.GetRange.get_range","title":"get_range","text":"<pre><code>get_range(\n    path: str, *, start: int, end: int | None = None, length: int | None = None\n) -&gt; Buffer\n</code></pre> <p>Return the bytes stored at the specified location in the given byte range.</p> <p>If the given range is zero-length or starts after the end of the object, an error will be returned. Additionally, if the range ends after the end of the object, the entire remainder of the object will be returned. Otherwise, the exact requested range will be returned.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to retrieve.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>start</code>               (<code>int</code>)           \u2013            <p>The start of the byte range.</p> </li> <li> <code>end</code>               (<code>int | None</code>)           \u2013            <p>The end of the byte range (exclusive). Either <code>end</code> or <code>length</code> must be non-None.</p> </li> <li> <code>length</code>               (<code>int | None</code>)           \u2013            <p>The number of bytes of the byte range. Either <code>end</code> or <code>length</code> must be non-None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Buffer</code>           \u2013            <p>A <code>Buffer</code> object implementing the Python buffer protocol.</p> </li> </ul>"},{"location":"api/get/#obspec.GetRangeAsync","title":"obspec.GetRangeAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.GetRangeAsync.get_range_async","title":"get_range_async  <code>async</code>","text":"<pre><code>get_range_async(\n    path: str, *, start: int, end: int | None = None, length: int | None = None\n) -&gt; Buffer\n</code></pre> <p>Call <code>get_range</code> asynchronously.</p> <p>Refer to the documentation for GetRange.</p>"},{"location":"api/get/#obspec.GetRanges","title":"obspec.GetRanges","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.GetRanges.get_ranges","title":"get_ranges","text":"<pre><code>get_ranges(\n    path: str,\n    *,\n    starts: Sequence[int],\n    ends: Sequence[int] | None = None,\n    lengths: Sequence[int] | None = None,\n) -&gt; Sequence[Buffer]\n</code></pre> <p>Return the bytes stored at the specified location in the given byte ranges.</p> <p>The choice of how to implement multiple range requests is implementation specific.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to retrieve.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>starts</code>               (<code>Sequence[int]</code>)           \u2013            <p>A sequence of <code>int</code> where each offset starts.</p> </li> <li> <code>ends</code>               (<code>Sequence[int] | None</code>)           \u2013            <p>A sequence of <code>int</code> where each offset ends (exclusive). Either <code>ends</code> or <code>lengths</code> must be non-None.</p> </li> <li> <code>lengths</code>               (<code>Sequence[int] | None</code>)           \u2013            <p>A sequence of <code>int</code> with the number of bytes of each byte range. Either <code>ends</code> or <code>lengths</code> must be non-None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Sequence[Buffer]</code>           \u2013            <p>A sequence of <code>Buffer</code>, one for each range, each implementing the Python</p> </li> <li> <code>Sequence[Buffer]</code>           \u2013            <p>buffer protocol.</p> </li> </ul>"},{"location":"api/get/#obspec.GetRangesAsync","title":"obspec.GetRangesAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/get/#obspec.GetRangesAsync.get_ranges_async","title":"get_ranges_async  <code>async</code>","text":"<pre><code>get_ranges_async(\n    path: str,\n    *,\n    starts: Sequence[int],\n    ends: Sequence[int] | None = None,\n    lengths: Sequence[int] | None = None,\n) -&gt; Sequence[Buffer]\n</code></pre> <p>Call <code>get_ranges</code> asynchronously.</p> <p>Refer to the documentation for GetRanges.</p>"},{"location":"api/get/#obspec.GetOptions","title":"obspec.GetOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options for a get request.</p> <p>All options are optional.</p>"},{"location":"api/get/#obspec.GetOptions.head","title":"head  <code>instance-attribute</code>","text":"<pre><code>head: bool\n</code></pre> <p>Request transfer of no content</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-head</p>"},{"location":"api/get/#obspec.GetOptions.if_match","title":"if_match  <code>instance-attribute</code>","text":"<pre><code>if_match: str | None\n</code></pre> <p>Request will succeed if the <code>ObjectMeta::e_tag</code> matches.</p> <p>See datatracker.ietf.org/doc/html/rfc9110#name-if-match</p> <p>Examples:</p> <pre><code>If-Match: \"xyzzy\"\nIf-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-Match: *\n</code></pre>"},{"location":"api/get/#obspec.GetOptions.if_modified_since","title":"if_modified_since  <code>instance-attribute</code>","text":"<pre><code>if_modified_since: datetime | None\n</code></pre> <p>Request will succeed if the object has not been modified since.</p> <p>Some stores, such as S3, will only return <code>NotModified</code> for exact timestamp matches, instead of for any timestamp greater than or equal.</p> <p>datatracker.ietf.org/doc/html/rfc9110#section-13.1.4</p>"},{"location":"api/get/#obspec.GetOptions.if_none_match","title":"if_none_match  <code>instance-attribute</code>","text":"<pre><code>if_none_match: str | None\n</code></pre> <p>Request will succeed if the <code>ObjectMeta::e_tag</code> does not match.</p> <p>See datatracker.ietf.org/doc/html/rfc9110#section-13.1.2</p> <p>Examples:</p> <pre><code>If-None-Match: \"xyzzy\"\nIf-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-None-Match: *\n</code></pre>"},{"location":"api/get/#obspec.GetOptions.if_unmodified_since","title":"if_unmodified_since  <code>instance-attribute</code>","text":"<pre><code>if_unmodified_since: datetime | None\n</code></pre> <p>Request will succeed if the object has been modified since</p> <p>datatracker.ietf.org/doc/html/rfc9110#section-13.1.3</p>"},{"location":"api/get/#obspec.GetOptions.range","title":"range  <code>instance-attribute</code>","text":"<pre><code>range: tuple[int, int] | Sequence[int] | OffsetRange | SuffixRange\n</code></pre> <p>Request transfer of only the specified range of bytes.</p> <p>The semantics of this attribute are:</p> <ul> <li> <p><code>(int, int)</code>: Request a specific range of bytes <code>(start, end)</code>.</p> <p>If the given range is zero-length or starts after the end of the object, an error will be returned. Additionally, if the range ends after the end of the object, the entire remainder of the object will be returned. Otherwise, the exact requested range will be returned.</p> <p>The <code>end</code> offset is exclusive.</p> </li> <li> <p><code>{\"offset\": int}</code>: Request all bytes starting from a given byte offset.</p> <p>This is equivalent to <code>bytes={int}-</code> as an HTTP header.</p> </li> <li> <p><code>{\"suffix\": int}</code>: Request the last <code>int</code> bytes. Note that here, <code>int</code> is the     size of the request, not the byte offset. This is equivalent to <code>bytes=-{int}</code>     as an HTTP header.</p> </li> </ul> <p>datatracker.ietf.org/doc/html/rfc9110#name-range</p>"},{"location":"api/get/#obspec.GetOptions.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>Request a particular object version</p>"},{"location":"api/get/#obspec.GetResult","title":"obspec.GetResult","text":"<p>               Bases: <code>Iterable[Buffer]</code>, <code>Protocol</code></p> <p>Result for a get request.</p> <p>You can materialize the entire buffer by calling the <code>bytes</code> method or you can stream the result by iterating over it .</p> <p>Example:</p> <pre><code>from obspec import Get\n\ndef streaming_download(client: Get, path: str):\n    resp = client.get(path)\n    for buffer in resp:\n        print(len(buffer))\n</code></pre>"},{"location":"api/get/#obspec.GetResult.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: Attributes\n</code></pre> <p>Additional object attributes.</p>"},{"location":"api/get/#obspec.GetResult.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: ObjectMeta\n</code></pre> <p>The ObjectMeta for this object.</p>"},{"location":"api/get/#obspec.GetResult.range","title":"range  <code>property</code>","text":"<pre><code>range: tuple[int, int]\n</code></pre> <p>The range of bytes returned by this request.</p> <p>Note that this is <code>(start, stop)</code> not <code>(start, length)</code>.</p>"},{"location":"api/get/#obspec.GetResult.bytes","title":"bytes","text":"<pre><code>bytes() -&gt; Buffer\n</code></pre> <p>Collect the data into a <code>Buffer</code> object.</p> <p>This implements the Python buffer protocol. You can copy the buffer to Python memory by passing to <code>bytes</code>.</p>"},{"location":"api/get/#obspec.GetResultAsync","title":"obspec.GetResultAsync","text":"<p>               Bases: <code>AsyncIterable[Buffer]</code>, <code>Protocol</code></p> <p>Result for an async get request.</p> <p>You can materialize the entire buffer by calling the <code>bytes_async</code> method or you can stream the result by asynchronously iterating over it.</p> <p>Example:</p> <pre><code>from obspec import GetAsync\n\nasync def streaming_download(obs: GetAsync, path: str):\n    resp = await client.get_async(path)\n    async for buffer in resp:\n        print(len(buffer))\n</code></pre>"},{"location":"api/get/#obspec.GetResultAsync.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: Attributes\n</code></pre> <p>Additional object attributes.</p>"},{"location":"api/get/#obspec.GetResultAsync.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: ObjectMeta\n</code></pre> <p>The ObjectMeta for this object.</p>"},{"location":"api/get/#obspec.GetResultAsync.range","title":"range  <code>property</code>","text":"<pre><code>range: tuple[int, int]\n</code></pre> <p>The range of bytes returned by this request.</p> <p>Note that this is <code>(start, stop)</code> not <code>(start, length)</code>.</p>"},{"location":"api/get/#obspec.GetResultAsync.bytes_async","title":"bytes_async  <code>async</code>","text":"<pre><code>bytes_async() -&gt; Buffer\n</code></pre> <p>Collect the data into a <code>Buffer</code> object.</p> <p>This implements the Python buffer protocol. You can copy the buffer to Python memory by passing to <code>bytes</code>.</p>"},{"location":"api/get/#obspec.OffsetRange","title":"obspec.OffsetRange","text":"<p>               Bases: <code>TypedDict</code></p> <p>Request all bytes starting from a given byte offset.</p>"},{"location":"api/get/#obspec.OffsetRange.offset","title":"offset  <code>instance-attribute</code>","text":"<pre><code>offset: int\n</code></pre> <p>The byte offset for the offset range request.</p>"},{"location":"api/get/#obspec.SuffixRange","title":"obspec.SuffixRange","text":"<p>               Bases: <code>TypedDict</code></p> <p>Request up to the last <code>n</code> bytes.</p>"},{"location":"api/get/#obspec.SuffixRange.suffix","title":"suffix  <code>instance-attribute</code>","text":"<pre><code>suffix: int\n</code></pre> <p>The number of bytes from the suffix to request.</p>"},{"location":"api/head/","title":"Head","text":""},{"location":"api/head/#obspec.Head","title":"obspec.Head","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/head/#obspec.Head.head","title":"head","text":"<pre><code>head(path: str) -&gt; ObjectMeta\n</code></pre> <p>Return the metadata for the specified location.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ObjectMeta</code>           \u2013            <p>ObjectMeta</p> </li> </ul>"},{"location":"api/head/#obspec.HeadAsync","title":"obspec.HeadAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/head/#obspec.HeadAsync.head_async","title":"head_async  <code>async</code>","text":"<pre><code>head_async(path: str) -&gt; ObjectMeta\n</code></pre> <p>Call <code>head</code> asynchronously.</p> <p>Refer to the documentation for Head.</p>"},{"location":"api/list/","title":"List","text":""},{"location":"api/list/#obspec.List","title":"obspec.List","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/list/#obspec.List.list","title":"list","text":"<pre><code>list(\n    prefix: str | None = None, *, offset: str | None = None\n) -&gt; Iterator[Sequence[ObjectMeta]]\n</code></pre> <p>List all the objects with the given prefix.</p> <p>Prefixes are evaluated on a path segment basis, i.e. <code>foo/bar/</code> is a prefix of <code>foo/bar/x</code> but not of <code>foo/bar_baz/x</code>. List is recursive, i.e. <code>foo/bar/more/x</code> will be included.</p> <p>Examples:</p> <p>Synchronously iterate through list results:</p> <pre><code>import obspec\n\ndef upload_files(client: obspec.Put):\n    for i in range(100):\n        client.put(f\"file{i}.txt\", b\"foo\")\n\ndef list_files(client: obspec.List):\n    stream = client.list()\n    for list_result in stream:\n        print(list_result[0])\n        # {'path': 'file0.txt', 'last_modified': datetime.datetime(2024, 10, 23, 19, 19, 28, 781723, tzinfo=datetime.timezone.utc), 'size': 3, 'e_tag': '0', 'version': None}\n        break\n</code></pre> <p>Note</p> <p>The order of returned <code>ObjectMeta</code> is not guaranteed</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix within the store to use for listing. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>offset</code>               (<code>str | None</code>)           \u2013            <p>If provided, list all the objects with the given prefix and a location greater than <code>offset</code>. Defaults to <code>None</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Sequence[ObjectMeta]]</code>           \u2013            <p>A ListIterator, which you can iterate through to access list results.</p> </li> </ul>"},{"location":"api/list/#obspec.ListAsync","title":"obspec.ListAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/list/#obspec.ListAsync.list_async","title":"list_async","text":"<pre><code>list_async(\n    prefix: str | None = None, *, offset: str | None = None\n) -&gt; AsyncIterator[Sequence[ObjectMeta]]\n</code></pre> <p>List all the objects with the given prefix.</p> <p>Note that this method itself is not async. It's a synchronous method but returns an async iterator.</p> <p>Refer to obspec.List for more information about list semantics.</p> <p>Examples:</p> <p>Asynchronously iterate through list results. Just change <code>for</code> to <code>async for</code>:</p> <pre><code>stream = obs.list_async(store)\nasync for list_result in stream:\n    print(list_result[2])\n    # {'path': 'file10.txt', 'last_modified': datetime.datetime(2024, 10, 23, 19, 21, 46, 224725, tzinfo=datetime.timezone.utc), 'size': 3, 'e_tag': '10', 'version': None}\n    break\n</code></pre> <p>Note</p> <p>The order of returned <code>ObjectMeta</code> is not guaranteed</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix within the store to use for listing. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>offset</code>               (<code>str | None</code>)           \u2013            <p>If provided, list all the objects with the given prefix and a location greater than <code>offset</code>. Defaults to <code>None</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[Sequence[ObjectMeta]]</code>           \u2013            <p>A ListStream, which you can iterate through to access list results.</p> </li> </ul>"},{"location":"api/list/#obspec.ListWithDelimiter","title":"obspec.ListWithDelimiter","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/list/#obspec.ListWithDelimiter.list_with_delimiter","title":"list_with_delimiter","text":"<pre><code>list_with_delimiter(\n    prefix: str | None = None,\n) -&gt; ListResult[Sequence[ObjectMeta]]\n</code></pre> <p>List objects with the given prefix and an implementation specific delimiter.</p> <p>Returns common prefixes (directories) in addition to object metadata.</p> <p>Prefixes are evaluated on a path segment basis, i.e. <code>foo/bar/</code> is a prefix of <code>foo/bar/x</code> but not of <code>foo/bar_baz/x</code>. This list is not recursive, i.e. <code>foo/bar/more/x</code> will not be included.</p> <p>Note</p> <p>Any prefix supplied to this <code>prefix</code> parameter will not be stripped off the paths in the result.</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix within the store to use for listing. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ListResult[Sequence[ObjectMeta]]</code>           \u2013            <p>ListResult</p> </li> </ul>"},{"location":"api/list/#obspec.ListWithDelimiterAsync","title":"obspec.ListWithDelimiterAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/list/#obspec.ListWithDelimiterAsync.list_with_delimiter_async","title":"list_with_delimiter_async  <code>async</code>","text":"<pre><code>list_with_delimiter_async(\n    prefix: str | None = None,\n) -&gt; ListResult[Sequence[ObjectMeta]]\n</code></pre> <p>Call <code>list_with_delimiter</code> asynchronously.</p> <p>Refer to the documentation for ListWithDelimiter.</p>"},{"location":"api/list/#obspec.ListResult","title":"obspec.ListResult","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[ListChunkType_co]</code></p> <p>Result of a <code>list_with_delimiter</code> call.</p> <p>Includes objects, prefixes (directories) and a token for the next set of results. Individual result sets may be limited to 1,000 objects based on the underlying object storage's limitations.</p>"},{"location":"api/list/#obspec.ListResult.common_prefixes","title":"common_prefixes  <code>instance-attribute</code>","text":"<pre><code>common_prefixes: Sequence[str]\n</code></pre> <p>Prefixes that are common (like directories)</p>"},{"location":"api/list/#obspec.ListResult.objects","title":"objects  <code>instance-attribute</code>","text":"<pre><code>objects: ListChunkType_co\n</code></pre> <p>Object metadata for the listing</p>"},{"location":"api/list/#obspec.ListChunkType_co","title":"obspec.ListChunkType_co  <code>module-attribute</code>","text":"<pre><code>ListChunkType_co = TypeVar('ListChunkType_co', covariant=True)\n</code></pre> <p>The data structure used for holding list results.</p>"},{"location":"api/meta/","title":"Meta","text":""},{"location":"api/meta/#obspec.ObjectMeta","title":"obspec.ObjectMeta","text":"<p>               Bases: <code>TypedDict</code></p> <p>The metadata that describes an object.</p>"},{"location":"api/meta/#obspec.ObjectMeta.e_tag","title":"e_tag  <code>instance-attribute</code>","text":"<pre><code>e_tag: str | None\n</code></pre> <p>The unique identifier for the object</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-etag</p>"},{"location":"api/meta/#obspec.ObjectMeta.last_modified","title":"last_modified  <code>instance-attribute</code>","text":"<pre><code>last_modified: datetime\n</code></pre> <p>The last modified time</p>"},{"location":"api/meta/#obspec.ObjectMeta.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre> <p>The full path to the object</p>"},{"location":"api/meta/#obspec.ObjectMeta.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The size in bytes of the object</p>"},{"location":"api/meta/#obspec.ObjectMeta.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>A version indicator for this object</p>"},{"location":"api/put/","title":"Put","text":""},{"location":"api/put/#obspec.Put","title":"obspec.Put","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/put/#obspec.Put.put","title":"put","text":"<pre><code>put(\n    path: str,\n    file: IO[bytes]\n    | Path\n    | bytes\n    | Buffer\n    | Iterator[Buffer]\n    | Iterable[Buffer],\n    *,\n    attributes: Attributes | None = None,\n    tags: dict[str, str] | None = None,\n    mode: PutMode | None = None,\n    use_multipart: bool | None = None,\n    chunk_size: int = ...,\n    max_concurrency: int = ...,\n) -&gt; PutResult\n</code></pre> <p>Save the provided bytes to the specified location.</p> <p>The operation is guaranteed to be atomic, it will either successfully write the entirety of <code>file</code> to <code>location</code>, or fail. No clients should be able to observe a partially written object.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store for where to save the file.</p> </li> <li> <code>file</code>               (<code>IO[bytes] | Path | bytes | Buffer | Iterator[Buffer] | Iterable[Buffer]</code>)           \u2013            <p>The object to upload. Supports various input:</p> <ul> <li>A file-like object opened in binary read mode</li> <li>A <code>Path</code> to a local file</li> <li>A <code>bytes</code> object.</li> <li>Any object implementing the Python buffer protocol (includes <code>bytes</code> but also <code>memoryview</code>, numpy arrays, and more).</li> <li>An iterator or iterable of objects implementing the Python buffer protocol.</li> </ul> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>mode</code>               (<code>PutMode | None</code>)           \u2013            <p>Configure the <code>PutMode</code> for this operation. Refer to the <code>PutMode</code> docstring for more information.</p> <p>If this provided and is not <code>\"overwrite\"</code>, a non-multipart upload will be performed. Defaults to <code>\"overwrite\"</code>.</p> </li> <li> <code>attributes</code>               (<code>Attributes | None</code>)           \u2013            <p>Provide a set of <code>Attributes</code>. Defaults to <code>None</code>.</p> </li> <li> <code>tags</code>               (<code>dict[str, str] | None</code>)           \u2013            <p>Provide tags for this object. Defaults to <code>None</code>.</p> </li> <li> <code>use_multipart</code>               (<code>bool | None</code>)           \u2013            <p>Whether to force using a multipart upload.</p> <p>If <code>True</code>, the upload will always use a multipart upload, even if the length of the file is less than <code>chunk_size</code>. If <code>False</code>, the upload will never use a multipart upload, and the entire input will be materialized in memory as part of the upload. If <code>None</code>, the implementation will choose whether to use a multipart upload based on the length of the file and <code>chunk_size</code>.</p> <p>Defaults to <code>None</code>.</p> </li> <li> <code>chunk_size</code>               (<code>int</code>)           \u2013            <p>The size of chunks to use within each part of the multipart upload. The default is allowed to be implementation-specific.</p> </li> <li> <code>max_concurrency</code>               (<code>int</code>)           \u2013            <p>The maximum number of chunks to upload concurrently. This impacts the memory usage of large file uploads. The default is allowed to be implementation-specific.</p> </li> </ul>"},{"location":"api/put/#obspec.PutAsync","title":"obspec.PutAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/put/#obspec.PutAsync.put_async","title":"put_async  <code>async</code>","text":"<pre><code>put_async(\n    path: str,\n    file: IO[bytes]\n    | Path\n    | bytes\n    | Buffer\n    | AsyncIterator[Buffer]\n    | AsyncIterable[Buffer]\n    | Iterator[Buffer]\n    | Iterable[Buffer],\n    *,\n    attributes: Attributes | None = None,\n    tags: dict[str, str] | None = None,\n    mode: PutMode | None = None,\n    use_multipart: bool | None = None,\n    chunk_size: int = ...,\n    max_concurrency: int = ...,\n) -&gt; PutResult\n</code></pre> <p>Call <code>put</code> asynchronously.</p> <p>Refer to the documentation for <code>Put</code>. In addition to what the synchronous <code>put</code> allows for the <code>file</code> parameter, this also supports an async iterator or iterable of objects implementing the Python buffer protocol.</p> <p>This means, for example, you can pass the result of <code>get_async</code> directly to <code>put_async</code>, and the request will be streamed through Python during the put operation:</p> <pre><code>from obspec import GetAsync, PutAsync\n\nasync def streaming_copy(\n    fetch_client: GetAsync,\n    put_client: PutAsync,\n    path1: str,\n    path2: str,\n):\n    # This only constructs the stream, it doesn't materialize the data in memory\n    resp = await fetch_client.get_async(path1)\n    # A streaming upload is created to copy the file to path2\n    await put_client.put_async(path2, resp)\n</code></pre>"},{"location":"api/put/#obspec.PutResult","title":"obspec.PutResult","text":"<p>               Bases: <code>TypedDict</code></p> <p>Result for a put request.</p>"},{"location":"api/put/#obspec.PutResult.e_tag","title":"e_tag  <code>instance-attribute</code>","text":"<pre><code>e_tag: str | None\n</code></pre> <p>The unique identifier for the newly created object</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-etag</p>"},{"location":"api/put/#obspec.PutResult.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>A version indicator for the newly created object.</p>"},{"location":"api/put/#obspec.UpdateVersion","title":"obspec.UpdateVersion","text":"<p>               Bases: <code>TypedDict</code></p> <p>Uniquely identifies a version of an object to update.</p> <p>Stores will use differing combinations of <code>e_tag</code> and <code>version</code> to provide conditional updates, and it is therefore recommended applications preserve both</p>"},{"location":"api/put/#obspec.UpdateVersion.e_tag","title":"e_tag  <code>instance-attribute</code>","text":"<pre><code>e_tag: str | None\n</code></pre> <p>The unique identifier for the newly created object.</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-etag</p>"},{"location":"api/put/#obspec.UpdateVersion.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>A version indicator for the newly created object.</p>"},{"location":"api/put/#obspec.PutMode","title":"obspec.PutMode  <code>module-attribute</code>","text":"<pre><code>PutMode: TypeAlias = Union[Literal['create', 'overwrite'], UpdateVersion]\n</code></pre> <p>Configure preconditions for the put operation</p> <p>There are three modes:</p> <ul> <li>Overwrite: Perform an atomic write operation, overwriting any object present at the   provided path.</li> <li>Create: Perform an atomic write operation, returning   an error if an object already exists at the provided path.</li> <li>Update: Perform an atomic write operation if the current version of the object matches   the provided <code>UpdateVersion</code>, returning an error otherwise.</li> </ul> <p>If a string is provided, it must be one of:</p> <ul> <li><code>\"overwrite\"</code></li> <li><code>\"create\"</code></li> </ul> <p>If a <code>dict</code> is provided, it must meet the criteria of <code>UpdateVersion</code>.</p>"},{"location":"api/rename/","title":"Rename","text":""},{"location":"api/rename/#obspec.Rename","title":"obspec.Rename","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/rename/#obspec.Rename.rename","title":"rename","text":"<pre><code>rename(from_: str, to: str, *, overwrite: bool = True) -&gt; None\n</code></pre> <p>Move an object from one path to another in the same object store.</p> <p>By default, this is implemented as a copy and then delete source. It may not check when deleting source that it was the same object that was originally copied.</p> <p>Parameters:</p> <ul> <li> <code>from_</code>               (<code>str</code>)           \u2013            <p>Source path</p> </li> <li> <code>to</code>               (<code>str</code>)           \u2013            <p>Destination path</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>overwrite</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, if there exists an object at the destination, it will be overwritten. If <code>False</code>, will return an error if the destination already has an object.</p> </li> </ul>"},{"location":"api/rename/#obspec.RenameAsync","title":"obspec.RenameAsync","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/rename/#obspec.RenameAsync.rename_async","title":"rename_async  <code>async</code>","text":"<pre><code>rename_async(from_: str, to: str, *, overwrite: bool = True) -&gt; None\n</code></pre> <p>Call <code>rename</code> asynchronously.</p> <p>Refer to the documentation for Rename.</p>"},{"location":"blog/","title":"Blog","text":""}]}